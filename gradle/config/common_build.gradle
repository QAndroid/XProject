project.ext {
    //是否是独立调试，如果是login、introduce组件可以独立运行调试
    isDebug = true;

    setAndroidConfig = {
        extension ->
            //编译的sdk版本
            extension.compileSdkVersion project.ext.compilesdk_version
            //构建工具的版本
            extension.buildToolsVersion project.ext.build_tools_version

            //签名配置，参考：https://developer.android.com/studio/publish/app-signing
            extension.signingConfigs {
                //发布构建签名配置
                release {
                    //密钥库文件，一个包含一组私钥的二进制文件，变量保存在gradle.properties中
                    storeFile file(STOREFILE)
                    //密钥库密码，变量保存在.bash_profile环境变量中，参考：
                    //隐藏密码-https://www.jianshu.com/p/714ea34f739a
                    //配置签名设置-https://developer.android.com/studio/build/build-variants
                    storePassword System.getenv("KSTOREPWD")
                    keyAlias = 'xproject'
                    keyPassword System.getenv("KKEYPWD")

                    //FIXME 为什么System.console()没有提示输入？？
                    //if (System.console() != null)
                    //  keyPassword System.console().readLine("\nKey password: ")
                }
            }

            //默认配置
            extension.defaultConfig {
                //最低支持版本、支持目标版本
                minSdkVersion project.ext.minsdk_version
                targetSdkVersion project.ext.targetsdk_version

                //测试脚本
                testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

                //ARouter：annotationProcesser会使用javaCompileOptions配置类获取当前module的名字
                //Kotlin有自己独有的kapt框架做apt相关操作，的报错-There is no route match the path [/xxx/xxx], in group [xxx][ ]"
                //参考：https://juejin.im/post/593e5084128fe1006af179ad
                kapt {
                    arguments {
                        arg("AROUTER_MODULE_NAME", project.getName())
                    }
                }
            }

            //构建类型
            extension.buildTypes {
                //发布构建类型:代码压缩（混淆），清单文件占位（App名称）
                release {
                    //签名配置：使用发布构建签名
                    signingConfig extension.signingConfigs.release
                }

                //调试构建类型，仅包含需要的配置，不包含压缩、签名等，加快开发构建速度
                debug {
                    //关闭代码压缩——代码压缩会拖慢构建速度，尽可能在调试构建中避免使用
                    minifyEnabled false
                    shrinkResources false

                    debuggable true

                    ext.enableCrashlytics = false
                }
            }

            //启动databinding
            extension.dataBinding {
                enabled = true
            }
    }

    setDependencies = {
        extension ->
            //主源集依赖项
            extension.implementation fileTree(dir: 'libs', include: ['*.jar'])

            //FIXME 这个具体的作用？？
            extension.implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
            extension.implementation "androidx.core:core-ktx:$project.ext.core_ktx_version"
            //FIXME arouter和room未什么不可以和eventbus一样放在event组件中，间接有base提供依赖？？难道是kapt原因？？
            //ARoter:替换成最新版本,需要注意的是api。要与compiler匹配使用，均使用最新版可以保证兼容
            //每个模块需要ARouter apt引用，不然无法在apt中生成索引文件，无法成功跳转
            //每个模块需要ARouter api引用，不然构建报错：ARouter::Compiler The user has configuration the module name, it was [eventbus]
            extension.implementation "com.alibaba:arouter-api:$project.ext.arouter_api_version"
            extension.kapt "com.alibaba:arouter-compiler:$project.ext.arouter_compiler_version"
            //Room:基于编译时注解，每个模块都需要依赖kapt，无法通过api引用传递
            //添加Room
            extension.implementation "androidx.room:room-runtime:$project.ext.room_version"
            extension.kapt "androidx.room:room-compiler:$project.ext.room_version"

            //设备化测试源集依赖
            //databinding相关
            //运行Espresso，报错：java.lang.NoClassDefFoundError: Failed resolution of: Landroidx/databinding/DataBinderMapperImpl;
            //at androidx.databinding.DataBindingUtil.<clinit>(DataBindingUtil.java:32)
            //参考：http://www.ojit.com/article/49133
            extension.kaptAndroidTest "androidx.databinding:databinding-compiler:$project.ext.databinding_compiler_version"
            extension.testImplementation "junit:junit:$project.ext.junit_version"
            extension.testImplementation "org.mockito:mockito-core:$project.ext.mockito_version"
            extension.testImplementation "org.mockito:mockito-inline:$project.ext.mockito_version"
            extension.testImplementation "com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"
    }

    setRepositories = {
        extension ->
            extension.mavenCentral()
    }

    setConfigurations = {
        extension ->
            extension.all {
                //问题：Cannot find a version of 'androidx.lifecycle:lifecycle-runtime' that satisfies the version constraints:
                //解决办法，明确制定冲突版本
                //参考：https://blog.csdn.net/Weiye__Lee/article/details/79472501
                resolutionStrategy {
                    force "androidx.lifecycle:lifecycle-runtime:$project.ext.lifecycle_runtime_version"
                    force "androidx.collection:collection:$project.ext.collection_version"
                    force "androidx.core:core:$project.ext.core_version"
                    force "androidx.fragment:fragment:$project.ext.fragment_version"
                }
            }
    }

    setCommonConfig = {
        extension ->
            extension.apply plugin: 'kotlin-android'
            extension.apply plugin: 'kotlin-android-extensions'
            extension.apply plugin: 'kotlin-kapt'

            //引入额外Gradle配置文件
            extension.apply from: "${rootProject.rootDir}/versions_build.gradle"

            setAndroidConfig extension.android
            setDependencies extension.dependencies
            setRepositories extension.repositories
            setConfigurations extension.configurations
    }

    //App模块默认的配置
    setAppDefaultConfig = {
        extension ->
            //引入编译构建Gradle插件
            extension.apply plugin: 'com.android.application'
            //引入资源混淆插件
            extension.apply plugin: 'AndResGuard'
            setCommonConfig extension

            extension.android.defaultConfig {
                //应用id，extension.getName相当于project.getName()，默认applicationId后添加module名字，用于区分不同module产生的单独App
                applicationId applicationId + "." + extension.getName()
            }
    }

    //Library模块默认的配置
    setLibDefaultConfig = {
        extension ->
            extension.apply plugin: 'com.android.library'
            //maven插件，用于library发布aar到本地repo
            //参考：https://www.jianshu.com/p/0629548ab5a4
            extension.apply plugin: 'maven'
            setCommonConfig extension

            //指定一个proguard配置，这个配置会打入aar
            //和proguardFiles属性指定的proguard不同，proguardFiles是用于构建aar的混淆规则，consumerProguardFiles是接入方在构建时使用的混淆规则
            //在构建的时候会合并到app module的混淆文件，其中的规则也会影响接入方的混淆
            //参考：https://www.jianshu.com/p/14af4a474d55
            extension.android.defaultConfig.consumerProguardFiles 'proguard-rules.pro'

            extension.android.buildTypes {
                release {
                    //在组件化中，如果每个module都使用自身混淆，则会出现重复混淆的现象，造成查询不到资源文件的问题
                    minifyEnabled false
                    shrinkResources false
                }
            }

            //将打包好的aar，发布到../repo目录的本地库
            uploadArchives {
                repositories {
                    mavenDeployer {
                        repository(url: uri("../repo"))
                    }
                }
            }
    }
}