import com.android.build.OutputFile

apply from: "${rootProject.rootDir}/common_build.gradle"
//Application module配置
project.ext.setAppDefaultConfig project

int MILLIS_IN_MINUTE = 1000 * 60
int minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE

android {
    defaultConfig {
        //应用ID，参考：https://developer.android.com/studio/build/application-id
        applicationId "workshop1024.com.xproject"

        //动态设置versionCode和versionName任意两个值，将会触发全量的APK构建和安装，
        //因为AndroidManifest.xml必须更新(它不支持Instant Run)
        //版本号、版本名称
        versionCode 1
        versionName "1.0"

        //明确定义测试应用ID，默认应用ID后追加.test
        testApplicationId "workshop1024.com.xproject.test"

        //启动Multidex，参考：https://developer.android.com/studio/build/multidex
        //打开Multidex，会导致构建缓存关闭，参考：https://developer.android.com/studio/build/build-cache
        multiDexEnabled true

        //使用variant-aware依赖管理，home库包含的develop，channel维度，app不包含
        //参考：https://developer.android.com/studio/build/dependencies
        missingDimensionStrategy 'develop', 'mock', 'dev', 'prod'
        missingDimensionStrategy 'channel', 'baidu', 'xiaomi'
    }

    buildTypes {
        //发布构建类型:代码压缩（混淆），清单文件占位（App名称）
        release {
            //打开代码压缩——1.移除未使用的类、字段、方法属性，包括自带代码库中；2.优化字节码，移除未使用的代码指令；3.短名称混淆其余类、字段和方法
            //参考：https://developer.android.com/studio/build/shrink-code?hl=zh-CN
            //打开代码压缩，会导致构建缓存关闭，参考：https://developer.android.com/studio/build/build-cache
            minifyEnabled true
            //ProGuard路径——从Android SDK/tools/proguard/文件夹获取默认的ProGuard设置
            //使用proguard-android-optimize.txt文件，包括其它在字节码一级（方法内和方法间）执行分析的优化
            //proguard-rules.pro文件用于添加自定义ProGuard规则
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            //打开资源压缩
            shrinkResources true

            //设置清单占位符——不同构建替换不同的清单文件配置。参考:https://blog.csdn.net/qq_21793463/article/details/52069127
            //应用Label——在设备上安装不同构建类型的APK后，应用名称好区分
            //应用Label：XProject
            //参考：https://developer.android.com/studio/build/manifest-build-variables?hl=zh-cn
            manifestPlaceholders = [label: "XProject"]
        }

        //调试构建类型，仅包含需要的配置，不包含压缩、签名等，加快开发构建速度
        debug {
            //applicationId：workshop1024.com.xproject.debug
            applicationIdSuffix ".debug"
            //应用Label：XProject—DB
            manifestPlaceholders = [label: "XProjet-D"]
        }

        staging {
            //initWith属性其它配置属性，然后设置你想修改
            initWith debug
            applicationIdSuffix ".debugStaging"

            //当依赖库不包含staging构建类型的时，插件尝试使用该列表中的构建
            //参考：解决与变体匹配相关的构建错误-https://developer.android.com/studio/build/dependencies
            matchingFallbacks = ['debug', 'release']
        }
    }

    //参考：创建源集-https://developer.android.com/studio/build/build-variants
    sourceSets {
        //staging构建类型源集配置
        staging {
            //资源目录
            //如果你设置列表，Gradle以相同的优先级，使用所有来收集资源
            //如果相同资源在超过一个目录中，merge资源时报错
            //注意，你必须避免制定的所有目录在同一个根目录，如：res.srcDirs = ['other/res1', 'other/res1/layouts', 'other/res1/strings']
            res.srcDirs = ['src/staging/res', 'src/main/res/staging']
            //清单文件目录
            manifest.srcFile 'src/main/staging/AndroidManifest.xml'
        }
    }

    splits {
        //根据屏幕密度配置构建多个apk
        density {
            //启动根据屏幕密度配置多个apk
            enable true
            //指定Gradle不生成apk的屏幕密度列表
            exclude "hdpi", "mhdpi", "xxhdpi"
            //为清单文件指定兼容的屏幕尺寸列表，仅用于第三方服务
            compatibleScreens 'small', 'normal', 'large', 'xlarge'
        }
        //根据ABI配置构建多个apk
        abi {
            //启动根据ABI构建多个apk
            enable true
            //默认情况下包含所有的ABIs，所以使用reset()，并且指定包含我们想要的x86和x86_64配置的APK
            //将Gradle创建APK的ABIs列表重置为空
            reset()
            //指定Gradle创建Apk的ABIs列表
            include 'armeabi-v7a', 'arm64-v8a', 'x86'
            //设置我们希望也生成一个包含所有ABIs的通用APK
            universalApk true
        }
    }
}

andResGuard {
    // mappingFile = file("./resource_mapping.txt")
    mappingFile = null
    use7zip = true
    useSign = true
    // 打开这个开关，会keep住所有资源的原始路径，只混淆资源的名字
    keepRoot = false
    // 设置这个值，会把arsc name列混淆成相同的名字，减少string常量池的大小
    fixedResName = "arg"
    // 打开这个开关会合并所有哈希值相同的资源，但请不要过度依赖这个功能去除去冗余资源
    mergeDuplicatedRes = true
    whiteList = [
            // for your icon
            "R.drawable.ic_launcher",
            // for fabric
            "R.string.com.crashlytics.*",
            // for google-services
            "R.string.google_app_id",
            "R.string.gcm_defaultSenderId",
            "R.string.default_web_client_id",
            "R.string.ga_trackingId",
            "R.string.firebase_database_url",
            "R.string.google_api_key",
            "R.string.google_crash_reporting_api_key"
    ]
    compressFilePattern = [
            "*.png",
            "*.jpg",
            "*.jpeg",
            "*.gif",
    ]
    sevenzip {
        artifact = 'com.tencent.mm:SevenZip:1.2.17'
        //path = "/usr/local/bin/7za"
    }

    /**
     * 可选： 如果不设置则会默认覆盖assemble输出的apk
     **/
    // finalApkBackupPath = "${project.rootDir}/final.apk"

    /**
     * 可选: 指定v1签名时生成jar文件的摘要算法
     * 默认值为“SHA-1”
     **/
    // digestalg = "SHA-256"
}

//给每个ABI的值设置一个版本号
ext.abiCodes = ['armeabi-v7a': 1, 'arm64-v8a': 2, 'x86': 3]

//上面defaultConfig值是固定的，所以你的增量构建不需要重新构建清单文件(因为整个APK，减慢了构建时间)
//但是release构建，没问题。下面的脚本遍历所有已知的variants，查找是"release"构建类型的，改变这些动态的属性
android.applicationVariants.all { variant ->
    if (variant.buildType.name == "release") {
        variant.outputs.each { output ->
            def baseAbiVersionCode = project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))
            if (baseAbiVersionCode != null) {
                output.versionCodeOverride = baseAbiVersionCode * 1000 + variant.versionCode;
            }
            output.versionNameOverride = minutesSinceEpoch + "-" + variant.flavorName;
        }
    }
}

//参考：https://developer.android.com/studio/build/dependencies
dependencies {
    //调整依赖顺序，构建顺序改变，当AndroidManifest.xml中Module中Application冲突时，解决后谁后编译使用谁
    //TODO 将所有的项目依赖 ，改成aar依赖。自动生成aar 主工程指定目录
    implementation project(':base')
    implementation project(':login')
    if (!project.ext.isIntroduceApp) {
        implementation project(':introduce')
    }
    implementation project(':main')
    implementation project(':home')
    implementation project(':save')
    implementation project(':settings')
    implementation project(':feedback')
    implementation "androidx.appcompat:appcompat:$project.ext.appcompat_version"
}
